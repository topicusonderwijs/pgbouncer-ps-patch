diff --git a/src/client.c b/src/client.c
index 28c6556..748270d 100644
--- a/src/client.c
+++ b/src/client.c
@@ -810,6 +810,9 @@ static bool handle_client_work(PgSocket *client, PktHdr *pkt)
 {
 	SBuf *sbuf = &client->sbuf;
 	int rfq_delta = 0;
+  const char *ps_name;
+  PgParsedPreparedStatement *ps = NULL;
+  PgClosePacket *close_packet;
 
 	switch (pkt->type) {
 
@@ -843,10 +846,72 @@ static bool handle_client_work(PgSocket *client, PktHdr *pkt)
 	 * to buffer packets until sync or flush is sent by client
 	 */
 	case 'P':		/* Parse */
+    if (!cf_disable_prepared_statement_support) {
+      if (!inspect_parse_packet(client, pkt, &ps_name))
+        return false;
+    }
+    break;
+
 	case 'E':		/* Execute */
+    break;
+
 	case 'C':		/* Close */
+    if (!cf_disable_prepared_statement_support) {
+      if (!unmarshall_close_packet(client, pkt, &close_packet))
+        return false;
+
+      if (close_packet && is_close_statement_packet(close_packet)) {
+        if (!handle_close_statement_command(client, pkt, close_packet))
+          return false;
+
+        client->pool->stats.client_bytes += pkt->len;
+
+        free(close_packet->name);
+        free(close_packet);
+
+        /* No further processing required */
+        return true;
+      }
+
+      if (close_packet) {
+        free(close_packet->name);
+        free(close_packet);
+      }
+    }
+    break;
+
 	case 'B':		/* Bind */
+    if (!cf_disable_prepared_statement_support) {
+      if (!inspect_bind_packet(client, pkt, &ps_name))
+        return false;
+
+      if (ps_name) {
+        HASH_FIND_STR(client->prepared_statements, ps_name, ps);
+        if (!ps) {
+          slog_error(client, "lookup failed for prepared statement '%s'", ps_name);
+          disconnect_client(client, true, "prepared statement '%s' not found", ps_name);
+          return false;
+        }
+      }
+    }
+    break;
+
 	case 'D':		/* Describe */
+    if (!cf_disable_prepared_statement_support) {
+      if (!inspect_describe_packet(client, pkt, &ps_name))
+        return false;
+
+      if (ps_name) {
+        HASH_FIND_STR(client->prepared_statements, ps_name, ps);
+        if (!ps) {
+          slog_error(client, "lookup failed for prepared statement '%s'", ps_name);
+          disconnect_client(client, true, "prepared statement '%s' not found", ps_name);
+          return false;
+        }
+      }
+    }
+    break;
+
 	case 'd':		/* CopyData(F/B) */
 		break;
 
@@ -860,7 +925,7 @@ static bool handle_client_work(PgSocket *client, PktHdr *pkt)
 		return false;
 	}
 
-	/* update stats */
+  /* update stats */
 	if (!client->query_start) {
 		client->pool->stats.query_count++;
 		client->query_start = get_cached_time();
@@ -890,6 +955,29 @@ static bool handle_client_work(PgSocket *client, PktHdr *pkt)
 	client->link->ready = false;
 	client->link->idle_tx = false;
 
+  if (!cf_disable_prepared_statement_support && ps_name) {
+    switch (pkt->type)
+    {
+      case 'P':
+        if (!handle_parse_command(client, pkt, ps_name))
+          return false;
+        free((char *)ps_name);
+        return true;
+
+      case 'B':
+        if (!handle_bind_command(client, pkt, ps_name))
+          return false;
+        free((char *)ps_name);
+        return true;
+
+      case 'D':
+        if (!handle_describe_command(client, pkt, ps_name))
+          return false;
+        free((char *)ps_name);
+        return true;
+    }
+  }
+
 	/* forward the packet */
 	sbuf_prepare_send(sbuf, &client->link->sbuf, pkt->len);
 
